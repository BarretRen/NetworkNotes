> 本文内容基于《TCP/IP 协议详解 卷一》

# 第一章 概述

## 1 分层

TCP/IP 协议族通常被认为是一个四层协议系统，每一层负责不同的功能：应用层关心的是应用程序的细节，而不是数据在网络中的传输活动。下三层对应用程序一无所知，但它们要处理所有的通信细节。

![image.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1605494249633-8d20813d-27f4-4053-8874-cfcc0ddcd3f2.png)

- 网络层 IP 提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。
- TCP 在不可靠的 IP 层上提供了一个可靠的运输层。为了提供这种可靠的服务， TCP 采用了**超时重传、发送和接收端到端的确认分组**等机制。

连接网络的途径是使用**路由器和网桥**：网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连。

## 2 互联网地址

IP 地址分为五类：**区分各类地址最简单的方法是看它的第一个十进制整数。**
![Alt text](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/image.png)
![Alt text](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/image-1.png)

## 3 子网和掩码

子网是在 ABC 类 ip 地址的主机号的基础上再分为子网+主机号，同一子网的 ip 可以相互通信，例如：

![1561045681894.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572398853-c4611262-ed10-4272-a455-456bd1f5fd21.png)
因此区分不同子网和 IP，需要知道**有多少比特用于子网号及多少比特用于主机号**。这是在引导过程中通过子网掩码来确定的。**子网掩码是一个 32 bit 的值，其中值为 1 的比特留给网络号和子网号，为 0 的比特留给主机号**。如下图，子网掩码为 255.255.255.0，也即/24：

![1561045894044.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572404211-f6f4d7cb-17d2-44ee-8e9c-d5780f64a4aa.png)
给定 IP 地址和子网掩码以后，主机就可以确定 IP 数据报的目的是：( 1)本子网上的主机；(2)本网络中其他子网中的主机；( 3)其他网络上的主机。例如下图，两个网络属于同一网络不同子网：

![1566446980317.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572413030-62a15810-f67f-4c7b-8dad-2e0ce3cf98c0.png)

## 4 封装和分用

**封装**：当应用程序用 TCP 传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息） ，该过程如下所示：

![image.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1605504857850-734589c6-d635-45f5-8a4d-612ce1f6aeca.png)

- IP 在首部中存入一个长度为 8 bit 的数值，称作协议域。 1 表示为 ICMP 协议， 2 表示为 IGMP 协议， 6 表示为 TCP 协议， 1 7 表示为 UDP 协议
- TCP 和 UDP 都用一个 16 bit 的端口号来表示不同的应用程序。TCP 和 UDP 把源端口号和目的端口号分别存入报文首部中
- 以太网的帧首部也有一个 16 bit 的帧类型域

**分用**：当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议都要去检查报文首部中的协议标识，以确定接收数据的上层协议。

![image.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1605505264952-6dce2d76-020b-480c-9964-913de71dcfbf.png)

# 第二章 链路层

## 1 链路层作用

链路层主要有三个目的：

- 为 IP 模块发送和接收 I P 数据报；
- 为 ARP 模块发送 ARP 请求和接收 ARP 应答；
- 为 RARP 发送 RARP 请求和接收 RARP 应答。

## 2 链路层协议

### 2.1 以太网和 IEEE 802 封装

两种帧格式都采用 48 bit（6 字节）的目的地址和源地址，ARP 和 RARP 协议对 32 bit 的 IP 地址和 48 bit 的硬件地址进行映射。

![1566440749256.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572346972-8452faef-78f8-4134-be57-b55c00828029.png)
802.3 标准定义的帧和以太网的帧都有最小长度要求。 802.3 规定数据部分必须至少为 38 字节，而对于以太网，则要求最少要有 46 字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。**以太网的封装格式**是最为常见的封装格式。

### 2.2 PPP：点对点协议

PPP 数据帧的格式看上去很像 ISO 的 HDLC（**Q921 桢**），每一帧都以标志字符 0x7e 开始和结束。紧接着是一个地址字节，值始终是 0xff，然后是一个值为 0x03 的控制字节。

![1566441132069.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572356622-729e13d6-8681-49b1-8b73-6383d86e6544.png)

### 2.3 环回接口 loopback

环回接口（Loopback Interface）允许运行在同一台主机上的客户程序和服务器程序通过 TCP/IP 进行通信。 A 类网络号 127 就是为环回接口预留的。根据惯例，大多数系统把 IP 地址 127.0.0.1 分配给这个接口，并命名为 localhost。

![1566443107883.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572364933-31e7c599-ecea-4f07-b84b-fb55e0d47f41.png)

## 3 最大传输单元 MTU

如果 I P 层有一个数据报要传，而且数据的长度比链路层的 M T U 还大，那么 IP 层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于 MTU。
下面是几种常见网络的 MTU 值：

|           网络            | MTU 字节 |
| :-----------------------: | :------: |
|          超通道           |  65535   |
|   16Mb/s 令牌环（IBM）    |  17914   |
| 4Mb/s 令牌环（IEEE 802.5) |   4464   |
|           FDDI            |   4352   |
|          以太网           |   1500   |
|     IEEE 802.3/802.2      |   1492   |
|           X.25            |   576    |
|        PPP 低时延         |   296    |

如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的 MTU。重要的不是两台主机所在网络的 MTU 的值，重要的是两台通信主机路径中的最小 MTU。它被称作**路径 MTU**。

# 第四/五章 ARP 和 RARP

## 1 ARP 广播过程

知道主机的 IP 地址并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。 ARP 的功能是在**32 bit 的 IP 地址和采用不同网络技术的硬件地址**之间提供动态映射。 ,上层程序不需要关心这个过程。

![1566465577177.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572426206-58a5781e-8a31-4c1a-962c-4dff1093ee3e.png)
ARP 高效运行的关键是由于每个主机上都有一个**ARP 高速缓存**。这个高速缓存存放了最近 Internet 地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为**20 分钟**。可用如下命令查看缓存：

```shell
> arp -a
? (135.252.28.130) at 2c:fa:a2:55:c7:17 [ether] on eth0
? (135.252.28.217) at 98:fa:9b:1c:05:ee [ether] on eth0
? (135.252.28.225) at 98:fa:9b:1b:fc:07 [ether] on eth0
? (135.252.28.254) at 2c:fa:a2:27:60:97 [ether] on eth0
? (135.252.28.215) at 3c:18:a0:be:de:73 [ether] on eth0
```

## 2 ARP 格式

ARP 请求和应答是相同的格式，如下：

![1566538259279.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572438230-17cbc894-5a67-4fe2-99a7-f03e65e0e7a4.png)

- ARP 的帧类型为：**0x0806**
- 硬件类型字段表示硬件地址的类型。它的值为 1 即表示以太网地址。
- 协议类型字段表示要映射的协议地址类型。它的值为 0x0800 即表示 IP 地址
- 操作字段指出四种操作类型，它们是**ARP 请求（值为 1）、 ARP 应答（值为 2）、RARP 请求（值为 3）和 RARP 应答（值为 4）**

对于一个 ARP 请求来说，**除目的端硬件地址外的所有其他的字段都有填充值**。当系统收到一份目的端为本机的 ARP 请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为 2，最后把它发送回去。
提供一个 ARP 服务器很简单，通常是 TCP/IP 在内核中实现的一部分。

## 3 ARP 代理

如果 ARP 请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托 ARP 或 ARP 代理。

## 4 免费 ARP

免费 ARP (gratuitous ARP)。它是指主机发送 ARP 查找自己的 I P 地址。通常，它发生在系统引导期间进行接口配置的时候。免费 ARP 有两个作用：

- 一个主机可以通过它来确定另一个主机是否设置了相同的 I P 地址
- 如果发送免费 A R P 的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。

## 5 RARP

RARP 分组的格式与 ARP 分组基本一致。它们之间主要的差别是 RARP 请求或应答的帧类型代码为**0x8035**，而且 RARP 请求的操作代码为 3，应答操作代码为 4。
RARP 服务器的功能就由用户进程来提供，而不是作为内核的 TCP/IP 实现的一部分。硬件地址到 I P 地址的映射包含在一个磁盘文件中（在 U n i x 系统中一般位于/etc/ethers 目录中）。

# 第六章 ICMP 控制报文协议

## 1 ICMP 格式和类型

ICMP 是 IP 层的一个组成部分。它**传递差错报文以及其他需要注意的信息**。ICMP 报文通常被 IP 层或更高协议（TCP 或 UDP）使用。 ICMP 是封装在 IP 数据包的内部，其格式如下：

![image.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1605504188713-f9c9265c-f062-408e-a960-b7e8c5e65899.png)

- 类型字段可以有 15 个不同的值，以描述特定类型的 ICMP 报文。某些 ICMP 报文还使用代码字段的值来进一步描述不同的条件

ICMP 的各个类型如下表，类型由类型字段和代码字段共同决定：

![1566543473168.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572461834-ae293a93-b036-4574-927a-1f4d01cc45fa.png)

## 2 常用类型介绍

### 2.1 地址掩码请求

ICMP 地址掩码请求用于无盘系统在引导过程中**获取自己的子网掩码** ，系统广播它的 ICMP 请求报文。该类型格式如下：

![1566543704887.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572469254-2b2e5b24-2a8c-492f-9475-297d1b3a7bd7.png)

### 2.2 时间戳请求

ICMP 时间戳请求允许系统向另一个系统**查询当前的时间**。返回的建议值是自午夜开始计算的毫秒数，协调的统一时间（UTC）。这种 ICMP 报文的好处是它提供了**毫秒级的分辨率**。格式如下：

![1566544013499.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572480926-d15849c4-5cdc-4377-8d40-4f27a6d69553.png)
请求端填写**发起时间戳**，然后发送报文。应答系统收到请求报文时填写**接收时间戳**，在发送应答时填写**发送时间戳**。

### 2.3 端口不可达错误

ICMP 的一个规则是， ICMP 差错报文必须包括生成该差错报文的数据报 IP 首部（包含任何选项），还必须至少包括跟在该 IP 首部后面的前 8 个字节。

![1566544420948.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572486484-32c0cbac-a525-4e0b-b465-983c444cd382.png)

### 2.4 回显请求

回显请求和应答一般用于**ping**程序，测试一台主机是否可达，格式如下：

Unix 系统在实现 ping 程序时是把 ICMP 报文中的标识符字段置成**发送进程的 ID 号**。这样即使在同一台主机上同时运行了多个 ping 程序实例， ping 程序也可以识别出返回的信息。

### 2.5 超时报文

有两种不同的 ICMP 超时报文，它们的 code 字段不同（11 和 12），超时报文格式如下：

![1566807195172.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572522755-47a3df74-fbcb-4230-a174-749498b19c39.png)

## 3 BSD 系统对 ICMP 各类消息的处理

由于 ICMP 覆盖的范围很广，从致命差错到信息差错，因此即使在一个给定的系统实现中，对每个 ICMP 报文的处理都是不相同的。

![1566544664938.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572533009-46faa7fe-7b73-4457-85a2-093619ec7c46.png)

# 第七章 Ping 程序

## 1 IP 记录路由选项

平提供**-R**选项，以提供记录路由的功能。它使得 ping 程序在发送出去的 IP 数据报中设置**IP RR 选项**（该 IP 数据报包含 ICMP 回显请求报文）。这样，每个处理该数据报的路由器都把它的 IP 地址放入选项字段中。当数据报到达目的端时，IP 地址清单应该复制到 ICMP 回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当 ping 程序收到回显应答时，它就打印出这份 IP 地址清单。
IP 数据报中的 R R 选项的一般格式：

![1566547048525.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572544785-1b1f8fec-ea11-4f2f-8b30-97a4264a1296.png)

- code：指定 IP 选项类型，对于 RR 值为 7
- len：RR 选项字段的总长度
- ptr：指针字段，指向存放下一个 IP 地址的位置

## 2 IP 时间戳选项

时间戳选项的代码为 0x44。其他两个字段 len 和 ptr 与记录路由选项相同：选项的总长度（一般为 36 或 40）和指向下一个可用空间的指针（ 5， 9， 1 3 等）。格式如下：

![1566744686758.png](TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80.assets/1579572553025-5f746178-00de-40a7-a88d-59d20c530989.png)
OF 表示溢出字段， FL 表示标志字段，有以下取值：

| 标志 | 描述                                                                                                                                              |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0    | 只记录时间戳                                                                                                                                      |
| 1    | 每台路由器都记录它的**IP 地址和时间戳**。在选项列表中只有存放 4 对地址和时间戳的空间                                                              |
| 3    | 发送端对选项列表进行初始化，存放了 4 个 IP 地址和 4 个取值为 0 的时间戳值。只有当列表中的下一个 IP 地址与当前路由器地址相匹配时，才记录它的时间戳 |

# 第八章 traceroute 程序

traceroute 程序可以让我们看到 IP 数据报从一台主机传到另一台主机所经过的路由。traceroute 程序还可以让我们使用 IP 源路由选项。

> 当路由器收到一份 IP 数据报，如果其 TTL 字段是 0 或 1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是在通常情况下，系统不应该接收 TTL 字段为 0 的数据报）。相反，路由器将该数据报丢弃，并给信源机发一份**ICMP“超时”信息**。 **traceroute 程序的关键在于包含这份 ICMP 信息的 IP 报文的信源地址是该路由器的 IP 地址**。

根据上面的原理，traceroute 的内部原理为：发送一份 TTL 字段为 1 的 I P 数据报给目的主机。处理这份数据报的第一个路由器将 TTL 值减 1，丢弃该数据报，并发回一份**超时 ICMP 报文**。这样就得到了该路径中的第一个路由器的地址。然后程序发送一份 TTL 值为 2 的数据报，这样我们就可以得到第二个路由器的地址...... 程序发送一份 UDP 数据包，选择一个不可能的值作为 UDP 端口，使得目的主机产生**端口不可达错误的 ICMP 报文**，traceroute 程序所要做的就是区分接收到的 ICMP 报文是超时还是端口不可达，以判断什么时候结束。
traceroute 命令运行格式如下：

```shell
> traceroute 172.24.213.162
traceroute to 172.24.213.162 (172.24.213.162), 30 hops max, 60 byte packets
 1  135.252.28.254 (135.252.28.254)  0.513 ms  0.475 ms  0.449 ms
 2  135.252.145.53 (135.252.145.53)  4.670 ms  4.922 ms  6.176 ms
 3  135.242.65.241 (135.242.65.241)  0.388 ms  0.691 ms  0.685 ms
 4  172.24.112.30 (172.24.112.30)  6.071 ms  6.075 ms  6.061 ms
 5  172.24.112.6 (172.24.112.6)  13.247 ms  13.239 ms  13.222 ms
 6  172.24.112.5 (172.24.112.5)  13.191 ms  16.209 ms  16.191 ms
 7  135.242.84.138 (135.242.84.138)  16.181 ms  16.159 ms  16.971 ms
 8  135.242.84.114 (135.242.84.114)  16.865 ms  16.856 ms  16.803 ms
 9  172.16.100.2 (172.16.100.2)  16.819 ms  16.786 ms  16.808 ms
10  172.24.213.162 (172.24.213.162)  16.761 ms  16.745 ms  16.729 ms
```
